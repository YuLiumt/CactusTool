{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "import ipywidgets as widgets\n",
    "from ipywidgets import interactive_output, HBox, VBox\n",
    "# from IPython.display import clear_output\n",
    "import matplotlib.pyplot as plt\n",
    "from CactusTool import pcolormesh\n",
    "import CactusTool\n",
    "\n",
    "name = 'HMNS_long'\n",
    "sim = CactusTool.load(name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d4c92145485c4a70b32e637e09035b95",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "VBox(children=(HBox(children=(Text(value='-50,50,-50,50', continuous_update=False, description='axlim:'), Textâ€¦"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "rho = sim.GF('xy', 'h5')['hydrobase-rho']\n",
    "\n",
    "it = rho.it\n",
    "# it_item = widgets.IntSlider(description='it:', value=0, min=it[0], max=it[-1], step=it[1] - it[0], continuous_update=False)\n",
    "it_item = widgets.Play(description='it:', value=0, min=it[0], max=it[-1], step=it[1] - it[0], interval=2000, disabled=False)\n",
    "slider = widgets.IntSlider(min=it[0], max=it[-1], step=it[1] - it[0])\n",
    "widgets.jslink((it_item, 'value'), (slider, 'value'))\n",
    "\n",
    "axlim_item = widgets.Text(value='-50,50,-50,50', description='axlim:', disabled=False, continuous_update=False)\n",
    "unit_item = widgets.Text(value='km, g/cm^3', description='units:', disabled=False, continuous_update=False)\n",
    "norm_item = widgets.Checkbox(value=True, description='Logarithmic:')\n",
    "\n",
    "def execute(it, log, axlim, unit):\n",
    "    p = rho.dsets('rho', it)\n",
    "    fig, ax = plt.subplots()\n",
    "    ax.set_xlabel('x')\n",
    "    ax.set_ylabel('y')\n",
    "    axlim = axlim.split(',')\n",
    "    ax.set_xlim(int(axlim[0]), int(axlim[1]))\n",
    "    ax.set_ylim(int(axlim[2]), int(axlim[3]))\n",
    "    unit = unit.split(',')\n",
    "#     ax.set_title(\"Time: {}\".format(p[0][0]['time']))\n",
    "    if log:\n",
    "        im = pcolormesh(ax, p, scale='log', unit=(unit[0], unit[1]))\n",
    "    else:\n",
    "        im = pcolormesh(ax, p, unit=unit)\n",
    "    fig.colorbar(im, ax=ax)\n",
    "   \n",
    "\n",
    "    \n",
    "    \n",
    "output = interactive_output(execute, \n",
    "                            {\n",
    "                                'it': it_item,\n",
    "                                'log': norm_item,\n",
    "                                'axlim': axlim_item,\n",
    "                                'unit': unit_item,\n",
    "                            })\n",
    "\n",
    "    \n",
    "VBox([\n",
    "    HBox([\n",
    "        axlim_item,\n",
    "        unit_item,\n",
    "        norm_item,\n",
    "    ]),\n",
    "    output,\n",
    "    HBox([it_item, slider])\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.colorbar.Colorbar at 0x7fe30dfd45c0>"
      ]
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from CactusTool import Units\n",
    "\n",
    "fig, axs = plt.subplots(2, 3, constrained_layout=True,figsize=(14,8))\n",
    "fig.suptitle(r\"$\\rho$\")\n",
    "\n",
    "ax = axs[0, 0]\n",
    "p = rho.dsets('rho', 0)\n",
    "ax.set_xlim(-50, 50)\n",
    "ax.set_ylim(-50, 50)\n",
    "ax.text(-45, -45, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "ax = axs[0, 1]\n",
    "p = rho.dsets('rho', 15232)\n",
    "ax.set_xlim(-100, 100)\n",
    "ax.set_ylim(-100, 100)\n",
    "ax.text(-90, -90, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "ax = axs[0, 2]\n",
    "p = rho.dsets('rho', 53248)\n",
    "ax.set_xlim(-100, 100)\n",
    "ax.set_ylim(-100, 100)\n",
    "ax.text(-90, -90, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "ax = axs[1, 0]\n",
    "p = rho.dsets('rho', 55040)\n",
    "ax.set_xlim(-150, 150)\n",
    "ax.set_ylim(-150, 150)\n",
    "ax.text(-135, -135, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "ax = axs[1, 1]\n",
    "p = rho.dsets('rho', 58880)\n",
    "ax.set_xlim(-150, 150)\n",
    "ax.set_ylim(-150, 150)\n",
    "ax.text(-135, -135, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "ax = axs[1, 2]\n",
    "p = rho.dsets('rho', 85888)\n",
    "ax.set_xlim(-150, 150)\n",
    "ax.set_ylim(-150, 150)\n",
    "ax.text(-135, -135, 't={:.2f} ms'.format(p[0][10]['time']*Units('ms')), fontsize=16)\n",
    "im = pcolormesh(ax, p, scale='log', unit=('km', 'g/cm^3'), cmap=plt.cm.cubehelix_r)\n",
    "\n",
    "\n",
    "fig.colorbar(im, ax=axs, orientation='vertical')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on method colorbar in module matplotlib.figure:\n",
      "\n",
      "colorbar(mappable, cax=None, ax=None, use_gridspec=True, **kw) method of matplotlib.figure.Figure instance\n",
      "    Create a colorbar for a ScalarMappable instance, *mappable*.\n",
      "    \n",
      "    Documentation for the pyplot thin wrapper:\n",
      "    \n",
      "    \n",
      "    Add a colorbar to a plot.\n",
      "    \n",
      "    Function signatures for the :mod:`~matplotlib.pyplot` interface; all\n",
      "    but the first are also method signatures for the\n",
      "    :meth:`~matplotlib.figure.Figure.colorbar` method::\n",
      "    \n",
      "      colorbar(**kwargs)\n",
      "      colorbar(mappable, **kwargs)\n",
      "      colorbar(mappable, cax=cax, **kwargs)\n",
      "      colorbar(mappable, ax=ax, **kwargs)\n",
      "    \n",
      "    Parameters\n",
      "    ----------\n",
      "    mappable\n",
      "        The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.Image`,\n",
      "        `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.\n",
      "        This argument is mandatory for the `.Figure.colorbar` method but optional\n",
      "        for the `.pyplot.colorbar` function, which sets the default to the current\n",
      "        image.\n",
      "    \n",
      "        Note that one can create a `ScalarMappable` \"on-the-fly\" to generate\n",
      "        colorbars not attached to a previously drawn artist, e.g. ::\n",
      "    \n",
      "            fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)\n",
      "    \n",
      "    cax : :class:`~matplotlib.axes.Axes` object, optional\n",
      "        Axes into which the colorbar will be drawn.\n",
      "    \n",
      "    ax : :class:`~matplotlib.axes.Axes`, list of Axes, optional\n",
      "        Parent axes from which space for a new colorbar axes will be stolen.\n",
      "        If a list of axes is given they will all be resized to make room for the\n",
      "        colorbar axes.\n",
      "    \n",
      "    use_gridspec : bool, optional\n",
      "        If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If\n",
      "        *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is\n",
      "        created as an instance of Subplot using the :mod:`~.gridspec` module.\n",
      "    \n",
      "    Returns\n",
      "    -------\n",
      "    colorbar : `~matplotlib.colorbar.Colorbar`\n",
      "        See also its base class, `~matplotlib.colorbar.ColorbarBase`.  Use\n",
      "        `~.ColorbarBase.set_label` to label the colorbar.\n",
      "    \n",
      "    Notes\n",
      "    -----\n",
      "    Additional keyword arguments are of two kinds:\n",
      "    \n",
      "      axes properties:\n",
      "    \n",
      "    \n",
      "        ============= ====================================================\n",
      "        Property      Description\n",
      "        ============= ====================================================\n",
      "        *orientation* vertical or horizontal\n",
      "        *fraction*    0.15; fraction of original axes to use for colorbar\n",
      "        *pad*         0.05 if vertical, 0.15 if horizontal; fraction\n",
      "                      of original axes between colorbar and new image axes\n",
      "        *shrink*      1.0; fraction by which to multiply the size of the colorbar\n",
      "        *aspect*      20; ratio of long to short dimensions\n",
      "        *anchor*      (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal;\n",
      "                      the anchor point of the colorbar axes\n",
      "        *panchor*     (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal;\n",
      "                      the anchor point of the colorbar parent axes. If\n",
      "                      False, the parent axes' anchor will be unchanged\n",
      "        ============= ====================================================\n",
      "    \n",
      "    \n",
      "      colorbar properties:\n",
      "    \n",
      "    \n",
      "        ============  ====================================================\n",
      "        Property      Description\n",
      "        ============  ====================================================\n",
      "        *extend*      [ 'neither' | 'both' | 'min' | 'max' ]\n",
      "                      If not 'neither', make pointed end(s) for out-of-\n",
      "                      range values.  These are set for a given colormap\n",
      "                      using the colormap set_under and set_over methods.\n",
      "        *extendfrac*  [ *None* | 'auto' | length | lengths ]\n",
      "                      If set to *None*, both the minimum and maximum\n",
      "                      triangular colorbar extensions with have a length of\n",
      "                      5% of the interior colorbar length (this is the\n",
      "                      default setting). If set to 'auto', makes the\n",
      "                      triangular colorbar extensions the same lengths as\n",
      "                      the interior boxes (when *spacing* is set to\n",
      "                      'uniform') or the same lengths as the respective\n",
      "                      adjacent interior boxes (when *spacing* is set to\n",
      "                      'proportional'). If a scalar, indicates the length\n",
      "                      of both the minimum and maximum triangular colorbar\n",
      "                      extensions as a fraction of the interior colorbar\n",
      "                      length. A two-element sequence of fractions may also\n",
      "                      be given, indicating the lengths of the minimum and\n",
      "                      maximum colorbar extensions respectively as a\n",
      "                      fraction of the interior colorbar length.\n",
      "        *extendrect*  bool\n",
      "                      If *False* the minimum and maximum colorbar extensions\n",
      "                      will be triangular (the default). If *True* the\n",
      "                      extensions will be rectangular.\n",
      "        *spacing*     [ 'uniform' | 'proportional' ]\n",
      "                      Uniform spacing gives each discrete color the same\n",
      "                      space; proportional makes the space proportional to\n",
      "                      the data interval.\n",
      "        *ticks*       [ None | list of ticks | Locator object ]\n",
      "                      If None, ticks are determined automatically from the\n",
      "                      input.\n",
      "        *format*      [ None | format string | Formatter object ]\n",
      "                      If None, the\n",
      "                      :class:`~matplotlib.ticker.ScalarFormatter` is used.\n",
      "                      If a format string is given, e.g., '%.3f', that is\n",
      "                      used. An alternative\n",
      "                      :class:`~matplotlib.ticker.Formatter` object may be\n",
      "                      given instead.\n",
      "        *drawedges*   bool\n",
      "                      Whether to draw lines at color boundaries.\n",
      "        ============  ====================================================\n",
      "    \n",
      "        The following will probably be useful only in the context of\n",
      "        indexed colors (that is, when the mappable has norm=NoNorm()),\n",
      "        or other unusual circumstances.\n",
      "    \n",
      "        ============   ===================================================\n",
      "        Property       Description\n",
      "        ============   ===================================================\n",
      "        *boundaries*   None or a sequence\n",
      "        *values*       None or a sequence which must be of length 1 less\n",
      "                       than the sequence of *boundaries*. For each region\n",
      "                       delimited by adjacent entries in *boundaries*, the\n",
      "                       color mapped to the corresponding value in values\n",
      "                       will be used.\n",
      "        ============   ===================================================\n",
      "    \n",
      "    \n",
      "    \n",
      "    If *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*\n",
      "    kwarg is included automatically.\n",
      "    \n",
      "    The *shrink* kwarg provides a simple way to scale the colorbar with respect\n",
      "    to the axes. Note that if *cax* is specified, it determines the size of the\n",
      "    colorbar and *shrink* and *aspect* kwargs are ignored.\n",
      "    \n",
      "    For more precise control, you can manually specify the positions of\n",
      "    the axes objects in which the mappable and the colorbar are drawn.  In\n",
      "    this case, do not use any of the axes properties kwargs.\n",
      "    \n",
      "    It is known that some vector graphics viewers (svg and pdf) renders white gaps\n",
      "    between segments of the colorbar.  This is due to bugs in the viewers, not\n",
      "    Matplotlib.  As a workaround, the colorbar can be rendered with overlapping\n",
      "    segments::\n",
      "    \n",
      "        cbar = colorbar()\n",
      "        cbar.solids.set_edgecolor(\"face\")\n",
      "        draw()\n",
      "    \n",
      "    However this has negative consequences in other circumstances, e.g. with\n",
      "    semi-transparent images (alpha < 1) and colorbar extensions; therefore, this\n",
      "    workaround is not used by default (see issue #1188).\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(fig.colorbar)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "12078.0"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
