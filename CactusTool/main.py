from .utils.log import logger
from .utils.check import ensure_list
from functools import cached_property
import os
import re
import glob


class load:
    """
    This is the main entry point into CactusTool.
    """

    def __init__(self, simname, basedir='~/simulations/', out_dir=None, output=None):
        """
        Load a Einstein Toolkit simulation.

        :param str simname: simulationname
        :param str basedir: basedir
        :param str out_dir: Output directory
        :param list output: Specify the desired checkpoints segments. None means all checkpoints.
        """
        if simname.endswith(os.path.sep):
            simname = simname[:-1]
        self.simname = simname
        basedir = os.path.expanduser(basedir)
        self.simpath = os.path.join(basedir, simname)
        # Make sure simulation directory exists.
        assert os.path.exists(self.simpath), "simulation name '{}' does not exist at path '{}'.".format(self.simname, basedir)
        if out_dir is None:
            out_dir = self.simname
        elif out_dir.endswith(os.path.sep):
            out_dir = out_dir[:-1]
        self.out_dir = out_dir
        # The directory structure of SimFactory is different from the traditional one.        
        if self._simfactory:
            # checkpoints segments
            if output is None:
                self.output = [n for n in os.listdir(self.simpath) if re.match('^output-\d\d\d\d$', n)]
            else:
                self.output = ensure_list(output)
            self.output.sort()

    @cached_property
    def _simfactory(self):
        """
        Is the directory generated by SimFactory Tools?
        """
        return 'SIMFACTORY' in os.listdir(self.simpath)

    def Scalar(self, ftype):
        """
        Access time series data as output by CarpetASCII, including all the reductions.

        :param str ftype: Type of reduction.
            - scalar:  access to grid scalars.
            - minimum: access to minimum reduction.
            - maximum: access to maximum reduction.
            - norm1:   access to norm1 reduction.
            - norm2:   access to norm2 reduction.
            - average: access to average reduction.
            - infnorm: access to inf-norm reduction.
        """
        from .Carpet.Scalar import CarpetIOScalar

        assert ftype in ['', 'minimum', 'maximum', 'norm1', 'norm2', 'average', 'scalars', 'infnorm']

        if self._simfactory:
            # Data file is stored in multiple folders for SimFactory.
            fileList = []
            for n in self.output:
                path = os.path.join(self.simpath, n, self.out_dir)
                fileList += glob.glob(path+os.path.sep+'*.{}.asc'.format(ftype))
        else:
            fileList = glob.glob(self.simpath+os.path.sep+'*.{}.asc'.format(ftype))
        assert bool(fileList), "No file endwith '.{}.asc'".format(ftype)
        return CarpetIOScalar(fileList, ftype)


    def GridFunctions(self, dim='xy', ftype='h5'):
        """
        CarpetIOHDF5 or CarpetIOASCII output

        :param str dim: dimension
        :param str ftype: endwith
        """
        from .Carpet.GF import CarpetGF
        assert dim in ['x', 'y', 'z', 'xy', 'xz', 'yz', 'xyz']
        assert ftype in ['asc', 'h5']
        if self._simfactory: 
            # Data file is stored in multiple folders for SimFactory.
            fileList = []
            for n in self.output:
                path = os.path.join(self.simpath, n, self.out_dir)
                fileList += glob.glob(path+os.path.sep+'*.{}.*{}'.format(dim, ftype))
        else:
            fileList = glob.glob(self.simpath+os.path.sep+'*.{}.*{}'.format(dim, ftype))
        assert bool(fileList), "{} don't have '{}' dim in '.{}' ftype".format(self.simname, dim, ftype)
        return CarpetGF(fileList, dim, ftype)

    GF = GridFunctions

    def ThornOutput(self, Thorn, out_dir=None, filename=None, **kwargs):
        """
        Other thorn's output. 

        The current support is as follows:
        [multipole, volumeintegrals_grmhd, puncturetracker]

        :param str thorn: thorn name
        :param str out_dir: Output directory
        :param str filename: file name
        """
        from .Carpet import ThornOutput

        thorn = Thorn.lower()

        ThornFile = {
            'multipole': 'mp_*',
            'volumeintegrals_grmhd': 'volume_integrals-GRMHD.asc',
            'twopunctures': 'TwoPunctures.bbh',
            'puncturetracker': 'puncturetracker-pt_loc..asc',
            'quasilocalmeasures': 'quasilocalmeasures-qlm_scalars..asc',
            'ahfinderdirect': 'BH_diagnostics.ah*.gp',
            'carpet': 'carpet-*.asc',
            'nanchecker': 'NaNmask.file_*.h5',
        }
        if filename is None:
            assert thorn in ThornFile.keys(), "Specify filename"
            filename = ThornFile[thorn]
        
        if self._simfactory:
            if out_dir is None:
                out_dir = self.out_dir
            # Data file is stored in multiple folders for SimFactory.
            fileList = []
            for n in self.output:
                path = os.path.join(self.simpath, n, out_dir)
                fileList += glob.glob(path+os.path.sep+filename)
        else:
            fileList = glob.glob(self.simpath+os.path.sep+filename)
        assert bool(fileList), "There are no data files about {}".format(Thorn)

        try:
            return getattr(ThornOutput, thorn)(fileList, **kwargs)
        except AttributeError:
            print("CactusTool currently not support %s thorn" % (Thorn))


    def Parfile(self, file=None):
        """
        Load parameter file if it exist. You can change the default file by use ‘Parfile(<parameter file>)’.

        :param str file: parameter file in absolute path.
        """
        from .Parameter.parfile import ParFile

        if file:
            assert os.path.exists(file), "parameter file '{}' not exists. Make sure it‘s an absolute path.".format(file)
            assert file.endswith('.par'), "parameter file '{}' should end with '.par'.".format(file)
            self.parfile = file
        else:
            if self._simfactory: 
                raise Exception("CactusTool currently cannot handle simfactory!")
            else:
                fileList = glob.glob(self.simpath + '*.par')
                if len(fileList) == 1:
                    self.parfile = fileList[0]
                else:
                    # Guess parfile you want to load
                    self.parfile = self.simpath + self.simname + '.par'
                    assert self.parfile in fileList, "Make sure `IO::out_dir = $parfile` in your parfile, or you can input the one you want to load."

            logger.info("Use the default parameter file '{}'.", self.parfile)
        return ParFile(self.parfile)

